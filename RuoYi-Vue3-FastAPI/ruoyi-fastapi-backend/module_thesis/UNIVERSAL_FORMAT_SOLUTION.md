# 通用格式解决方案（Universal Format Solution）

## 一、问题分析

不同学校有不同的论文格式要求，如何设计一个通用的解决方案？

### 1.1 挑战
- 不同学校的格式要求差异很大
- 格式细节繁多（字体、字号、行距、间距、空行等）
- 需要准确识别和提取格式
- 需要灵活应用格式

### 1.2 解决方案核心思想

**"从模板中提取，按指令执行"**

1. **模板驱动**：每个学校上传自己的格式模板
2. **AI提取**：AI从模板中提取所有格式细节
3. **指令生成**：生成结构化的格式化指令
4. **指令执行**：格式化代码按照指令执行

## 二、通用格式指令系统

### 2.1 指令结构设计

格式化指令采用分层结构，包含：
- **format_rules**：格式信息（字体、段落、标题、页面等）
- **layout_rules**：布局规则（空行、间距等）
- **application_rules**：应用规则（如何应用格式）

### 2.2 指令的通用性

指令系统设计为**完全通用**，因为：
1. **格式信息完整**：包含所有可能的格式属性
2. **布局规则详细**：包含所有布局细节（空行、间距等）
3. **从模板提取**：不依赖预设格式，从实际模板中提取
4. **灵活应用**：格式化代码按照指令灵活应用

## 三、目录格式识别方案

### 3.1 问题

Word文档的目录（TOC）是固定格式，需要识别目录条目的字体和大小。

### 3.2 解决方案

#### 方案1：识别目录区域段落（当前实现）

**优点**：
- 使用python-docx即可实现
- 不需要额外依赖

**实现方式**：
1. 识别目录标题（"目录"或"Table of Contents"）
2. 标记目录区域
3. 识别目录条目（通过特征识别）：
   - 包含章节编号（一、二、三、或1、2、3等）
   - 包含页码（数字结尾）
   - 包含点线（...）
4. 提取目录条目的格式信息

**代码实现**：
```python
# 识别目录条目
toc_patterns = [
    r'^[一二三四五六七八九十]+[、．]',  # 中文编号
    r'^\d+[、．]',  # 数字编号
    r'[．…]+',  # 点线
    r'\d+$',  # 以数字结尾（页码）
]
```

#### 方案2：使用docx2python库（备选）

如果python-docx无法满足需求，可以考虑使用docx2python库，它可能对TOC有更好的支持。

### 3.3 目录格式提取

从目录条目中提取：
- 字体名称
- 字体大小
- 行距
- 对齐方式
- 缩进值（用于区分不同级别）
- 段前距、段后距

### 3.4 多级目录识别

识别不同级别的目录条目：
- **一级目录**：如"一、绪论"（通常不缩进或缩进较少）
- **二级目录**：如"（一）"（通常缩进2字符）
- **三级目录**：如"1."（通常缩进4字符）

通过缩进值（left_indent）来区分级别。

## 四、不同学校格式的适配

### 4.1 适配策略

1. **模板上传**：每个学校上传自己的格式模板
2. **格式提取**：AI从模板中提取所有格式细节
3. **指令生成**：生成包含所有格式细节的格式化指令
4. **指令执行**：格式化代码按照指令执行

### 4.2 格式差异处理

不同学校的格式差异通过以下方式处理：

1. **字体差异**：
   - 学校A：标题用黑体 → 指令中记录"黑体"
   - 学校B：标题用楷体 → 指令中记录"楷体"
   - 格式化代码按照指令应用

2. **字号差异**：
   - 学校A：一级标题15磅 → 指令中记录15
   - 学校B：一级标题18磅 → 指令中记录18
   - 格式化代码按照指令应用

3. **布局差异**：
   - 学校A：标题后空1行 → layout_rules中记录after: 1
   - 学校B：标题后空2行 → layout_rules中记录after: 2
   - 格式化代码按照指令应用

4. **目录格式差异**：
   - 学校A：目录条目四号宋体 → 指令中记录font_size: 14
   - 学校B：目录条目小四号宋体 → 指令中记录font_size: 12
   - 格式化代码按照指令应用

### 4.3 指令的通用性保证

指令系统通过以下方式保证通用性：

1. **完整的格式属性**：包含所有可能的格式属性
2. **详细的布局规则**：包含所有布局细节
3. **从模板提取**：不依赖预设，从实际模板中提取
4. **灵活的执行逻辑**：格式化代码按照指令灵活执行

## 五、实施建议

### 5.1 模板要求

建议学校上传的模板包含：
1. 完整的论文结构（目录、摘要、正文、结论等）
2. 所有格式细节（字体、字号、行距、间距等）
3. 目录格式（如果可能，包含实际目录）

### 5.2 AI提取优化

1. **详细的提示词**：要求AI提取所有格式细节
2. **目录识别增强**：专门识别目录区域和目录条目
3. **多级标题识别**：识别不同级别的标题格式

### 5.3 格式化代码优化

1. **指令解析**：正确解析所有指令字段
2. **格式应用**：按照指令灵活应用格式
3. **布局应用**：按照layout_rules应用布局
4. **目录格式化**：按照目录格式指令格式化目录

## 六、示例：不同学校的格式适配

### 6.1 学校A格式

```json
{
  "format_rules": {
    "headings": {
      "h1": {
        "font_name": "黑体",
        "font_size": 15,
        "bold": true
      }
    },
    "special_formats": {
      "table_of_contents": {
        "entry_format": {
          "font_name": "宋体",
          "font_size": 12
        }
      }
    }
  },
  "layout_rules": {
    "heading_spacing": {
      "h1": {
        "after": 1
      }
    }
  }
}
```

### 6.2 学校B格式

```json
{
  "format_rules": {
    "headings": {
      "h1": {
        "font_name": "楷体",
        "font_size": 18,
        "bold": false
      }
    },
    "special_formats": {
      "table_of_contents": {
        "entry_format": {
          "font_name": "仿宋",
          "font_size": 14
        }
      }
    }
  },
  "layout_rules": {
    "heading_spacing": {
      "h1": {
        "after": 2
      }
    }
  }
}
```

### 6.3 系统处理

两个学校的格式都通过相同的系统处理：
1. 从模板中提取格式
2. 生成格式化指令
3. 按照指令执行格式化

**系统本身不需要知道是哪个学校，只需要按照指令执行即可。**

## 七、总结

通用格式解决方案的核心是：
1. **模板驱动**：每个学校上传自己的格式模板
2. **AI提取**：从模板中提取所有格式细节
3. **指令生成**：生成结构化的格式化指令
4. **指令执行**：格式化代码按照指令执行

这个方案的优势：
- **完全通用**：不需要为每个学校单独开发
- **灵活适应**：可以适应任何格式要求
- **易于维护**：格式变更只需更新模板
- **准确执行**：按照指令准确执行格式
